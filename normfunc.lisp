(in-package :cg-user)
(switch-reader)
(deffunction (not 1)
  (if (== cnil (%car args))
      (return tee)
      (return cnil)))
(deffunction (cons 2)
  (return (funcall _cons (%car args)
		   (%second args))))
(deffunction (atom 1)
  (decl ((o arg1 (%car args)))
    (if (%consp arg1)
	(return cnil)
	(return tee))))
(deffunction (listp 1)
  (decl ((o arg1 (%car args)))
    (if (%listp arg1)
	(return tee)
	(return cnil))))
(deffunction (eq 2)
  (decl ((o arg1 (%car args))
	 (o arg2 (%second args)))
    (if (funcall _eq arg1 arg2)
	(return tee)
	(return cnil))))
(deffunction (car 1)
  (return (funcall carx (%car args))))
(deffunction (cdr 1)
  (return (funcall cdrx (%car args))))
(deffunction (apply 2 127)
  (decl ((o previous NULL)
	 (o last args))
    (%dolist (e (%cdr last))
      (set previous last))
    (when (== 0 (%listp (%car last)))
      (%err "last arg not list"))
    (set (%cdr previous) (%car last))
    (return (funcall _apply (%car args)
		     (%cdr args)
		     (addr-of env)))))
(deffunction (add 0 127)
  (decl ((intgr result 0))
    (%dolist (item args)
      (decl ((intgr temp (funcall _integer item)))
	(set result (+ result temp))))
    (return (funcall _number result))))

(deffunction (less 1 127)
  (decl ((intgr arg1 (funcall _integer (%car args))))
	(set args (%cdr args))
	(%dolist (item args)
		 (decl ((intgr arg2 (funcall _integer item)))
		       (when (== 0 (< arg1 arg2))
			 (return cnil))
		       (set arg1 arg2)))
    (return tee)))

(deffunction (princ 1 1)
  (decl ((o obj (%car args)))
    (_print-object obj)
    (return obj)))

(deffunction (assoc 2 2)
  (decl ((o key (%car args))
	 (o list (%second args)))
    (when (== 0 (%listp list))
      (%err "last arg not list"))
    (%dolist (pair list)
      (when (== 1 (funcall _eq key (%car pair)))
	(return pair)))
    (return cnil)))

(deffunction (list 0 127)
  (return args))

(deffunction (length 1 1)
  (decl ((o list (%car args)))
    (when (== 0 (%listp list))
      (%err "arg not list"))
    (return (funcall _number (funcall listlength list)))))

(deffunction (reverse 1 1)
  (decl ((o list (%car args)))
    (when (== 0 (%listp list))
      (%err "arg not list"))
    (decl ((o result cnil))
      (%dolist (e list)
	(%push e result))
      (return result))))

(deffunction (second 1 1)
  (return (funcall carx (funcall cdrx (%car args)))))

(deffunction (third 1 1)
  (return (funcall carx (funcall cdrx (funcall cdrx (%car args))))))

(deffunction (showenv 0 0)
  (comment "(void) args;" :prefix "")
  (funcall _print-object global-env)
  (return cnil))
